/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  eta // clock
    , input  eta1 // reset
    , input  eta2 // enable
    , input signed [15:0] eta_0

      // Outputs
    , output wire signed [15:0] result
    );
  wire [79:0] c$app_arg;
  wire [79:0] c$app_arg_0;
  wire [79:0] c$vec1;

  assign c$vec1 = ({16'sd2,   16'sd2,   16'sd2,   16'sd2,   16'sd2});

  // zipWith start
  genvar i;
  generate
  for (i = 0; i < 5; i = i + 1) begin : zipWith
    wire signed [15:0] zipWith_in1;
    assign zipWith_in1 = c$vec1[i*16+:16];
    wire signed [15:0] zipWith_in2;
    assign zipWith_in2 = c$app_arg_0[i*16+:16];
    wire signed [15:0] c$n;
    assign c$n = zipWith_in1 * zipWith_in2;


    assign c$app_arg[i*16+:16] = c$n;
  end
  endgenerate
  // zipWith end

  wire signed [15:0] iterateI_ho1_0_res;
  wire signed [15:0] iterateI_ho1_1_res;
  wire signed [15:0] iterateI_ho1_2_res;
  wire signed [15:0] iterateI_ho1_3_res;
  reg signed [15:0] c$bb_res_res = 16'sd0;
  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$bb_res_res_register
    if ( eta1) begin
      c$bb_res_res <= 16'sd0;
    end else if (eta2) begin
      c$bb_res_res <= eta_0;
    end
  end
  // register end

  assign iterateI_ho1_0_res = c$bb_res_res;



  reg signed [15:0] c$bb_res_res_0 = 16'sd0;
  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$bb_res_res_0_register
    if ( eta1) begin
      c$bb_res_res_0 <= 16'sd0;
    end else if (eta2) begin
      c$bb_res_res_0 <= iterateI_ho1_0_res;
    end
  end
  // register end

  assign iterateI_ho1_1_res = c$bb_res_res_0;



  reg signed [15:0] c$bb_res_res_1 = 16'sd0;
  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$bb_res_res_1_register
    if ( eta1) begin
      c$bb_res_res_1 <= 16'sd0;
    end else if (eta2) begin
      c$bb_res_res_1 <= iterateI_ho1_1_res;
    end
  end
  // register end

  assign iterateI_ho1_2_res = c$bb_res_res_1;



  reg signed [15:0] c$bb_res_res_2 = 16'sd0;
  // register begin
  always @(posedge eta or  posedge  eta1) begin : c$bb_res_res_2_register
    if ( eta1) begin
      c$bb_res_res_2 <= 16'sd0;
    end else if (eta2) begin
      c$bb_res_res_2 <= iterateI_ho1_2_res;
    end
  end
  // register end

  assign iterateI_ho1_3_res = c$bb_res_res_2;



  assign c$app_arg_0 = {eta_0,
                        iterateI_ho1_0_res,   iterateI_ho1_1_res,
                        iterateI_ho1_2_res,   iterateI_ho1_3_res};



  wire [79:0] vec;
  wire signed [15:0] acc_3_0;
  wire signed [15:0] acc_1;
  wire signed [15:0] acc_2;
  wire signed [15:0] acc_3;
  wire signed [15:0] acc_4;
  wire signed [15:0] acc_1_0;
  wire signed [15:0] acc_1_1;
  wire signed [15:0] acc_2_0;
  wire signed [15:0] acc_5;
  assign result = acc_3_0;

  assign vec = c$app_arg;

  assign acc_1 = $signed(vec[79:64]);

  assign acc_2 = $signed(vec[63:48]);

  assign acc_3 = $signed(vec[47:32]);

  assign acc_4 = $signed(vec[31:16]);

  assign acc_5 = $signed(vec[15:0]);

  assign acc_1_0 = acc_1 + acc_2;



  assign acc_1_1 = acc_3 + acc_4;



  assign acc_2_0 = acc_1_0 + acc_1_1;



  assign acc_3_0 = acc_2_0 + acc_5;






endmodule

