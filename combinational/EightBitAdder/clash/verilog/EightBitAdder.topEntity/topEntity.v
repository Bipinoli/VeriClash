/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.4. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module topEntity
    ( // Inputs
      input  as_0
    , input  as_1
    , input  as_2
    , input  as_3
    , input  as_4
    , input  as_5
    , input  as_6
    , input  as_7
    , input  bs_0
    , input  bs_1
    , input  bs_2
    , input  bs_3
    , input  bs_4
    , input  bs_5
    , input  bs_6
    , input  bs_7
    , input  cin

      // Outputs
    , output wire  result_0
    , output wire  result_1_0
    , output wire  result_1_1
    , output wire  result_1_2
    , output wire  result_1_3
    , output wire  result_1_4
    , output wire  result_1_5
    , output wire  result_1_6
    , output wire  result_1_7
    );
  // EightBitAdder.hs:52:1-9
  wire [8:0] accs;
  // EightBitAdder.hs:52:1-9
  wire [15:0] ws;
  wire [7:0] c$app_arg;
  // EightBitAdder.hs:52:1-9
  wire [15:0] c$ws_app_arg;
  // EightBitAdder.hs:52:1-9
  wire [7:0] c$accs_app_arg;
  wire [7:0] as;
  wire [7:0] bs;
  wire [7:0] c$vec2;
  wire [8:0] result;
  wire [7:0] result_1_8;

  assign as = {as_0,   as_1,   as_2,   as_3,
               as_4,   as_5,   as_6,   as_7};

  assign bs = {bs_0,   bs_1,   bs_2,   bs_3,
               bs_4,   bs_5,   bs_6,   bs_7};

  assign accs = {c$accs_app_arg,cin};

  assign c$vec2 = (accs[8-1 : 0]);

  // zipWith start
  genvar i;
  generate
  for (i = 0; i < 8; i = i + 1) begin : zipWith
    wire [1:0] zipWith_in1;
    assign zipWith_in1 = c$ws_app_arg[i*2+:2];
    wire  zipWith_in2;
    assign zipWith_in2 = c$vec2[i*1+:1];
    wire [1:0] c$n;
    wire [1:0] result_2;
    // EightBitAdder.hs:52:1-9
    wire  a;
    // EightBitAdder.hs:52:1-9
    wire  b;
    // EightBitAdder.hs:52:1-9
    wire [1:0] ds;
    assign c$n = result_2;

    assign result_2 = {ds[0:0],   ds[1:1]};

    assign a = zipWith_in1[1:1];

    assign b = zipWith_in1[0:0];

    assign ds = {((a | b) | zipWith_in2) & ((a ^ b) ^ zipWith_in2),
                 ((a & b) | (b & zipWith_in2)) | (zipWith_in2 & a)};


    assign ws[i*2+:2] = c$n;
  end
  endgenerate
  // zipWith end

  assign result = {accs[9-1 -: 1],   c$app_arg};

  // map begin
  genvar i_0;
  generate
  for (i_0=0; i_0 < 8; i_0 = i_0 + 1) begin : map
    wire [1:0] map_in;
    assign map_in = ws[i_0*2+:2];
    wire  map_out;
    assign map_out = map_in[0:0];


    assign c$app_arg[i_0*1+:1] = map_out;
  end
  endgenerate
  // map end

  // zipWith start
  genvar i_1;
  generate
  for (i_1 = 0; i_1 < 8; i_1 = i_1 + 1) begin : zipWith_0
    wire  zipWith_in1_0;
    assign zipWith_in1_0 = as[i_1*1+:1];
    wire  zipWith_in2_0;
    assign zipWith_in2_0 = bs[i_1*1+:1];
    wire [1:0] c$n_0;
    assign c$n_0 = {zipWith_in1_0,   zipWith_in2_0};


    assign c$ws_app_arg[i_1*2+:2] = c$n_0;
  end
  endgenerate
  // zipWith end

  // map begin
  genvar i_2;
  generate
  for (i_2=0; i_2 < 8; i_2 = i_2 + 1) begin : map_0
    wire [1:0] map_in_0;
    assign map_in_0 = ws[i_2*2+:2];
    wire  map_out_0;
    assign map_out_0 = map_in_0[1:1];


    assign c$accs_app_arg[i_2*1+:1] = map_out_0;
  end
  endgenerate
  // map end

  assign result_0 = result[8:8];

  assign result_1_8 = result[7:0];

  assign result_1_0 = result_1_8[7:7];

  assign result_1_1 = result_1_8[6:6];

  assign result_1_2 = result_1_8[5:5];

  assign result_1_3 = result_1_8[4:4];

  assign result_1_4 = result_1_8[3:3];

  assign result_1_5 = result_1_8[2:2];

  assign result_1_6 = result_1_8[1:1];

  assign result_1_7 = result_1_8[0:0];


endmodule

